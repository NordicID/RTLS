/*
 * File: app/controller/TagDirectionController.js
 *
 * This file was generated by Sencha Architect version 4.3.6.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 7.8.x Modern library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 7.8.x Modern. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RFID_Tag_Locator_Service.controller.TagDirectionController', {
    extend: 'Ext.app.Controller',

    id: 'TagDirectionController',

    getTagDirection: function() {
        // ************   MODEL & STORE OBJECTS  ************
        var inventoryStore 			= Ext.data.StoreManager.lookup('InventoryStore');
        var bfaConfigData			= Ext.data.StoreManager.lookup('BfaConfigStore').getAt(0);


        // ************   VIEW OBJECTS  ************
        var inventoryGrid 			= Ext.getCmp('InventoryFromMqtt');
        var directionBarIn			= Ext.getCmp('directionBarIn');
        var directionBarOut			= Ext.getCmp('directionBarOut');
        var inGrid					= Ext.getCmp('TagsInside');
        var outGrid					= Ext.getCmp('TagsOutside');
        var bfaTopOrientation 		= Ext.data.StoreManager.lookup('BfaConfigStore').getAt(0).get('Orientation');
        // Default value of Top Side of BFA Orientation points to OUT Direction
        // Change this when selected value is IN Direction
        if (bfaTopOrientation === 'In') {
            var inArrow 	= Ext.getCmp('inArrow');
            var outArrow 	= Ext.getCmp('outArrow');
            inArrow.setSrc('images/arrow/up-arrow-shadow.png');
            outArrow.setSrc('images/arrow/down-arrow-shadow.png');

        }

        // ************   BEAM OBJECTS  ************
        var QuadrantBeam 			= Ext.getCmp('beam26Sim').getSurface('QuadrantSurface');
        var OutsideClipPath 		= 'clip-path: path("m221.99998,246.99998c0,0 -222.99999,-28 -222.99998,-28.99998c-0.00001,0.99998 -1.00001,-119.00001 -1,-219c-0.00001,-0.00001 447.99997,-0.00001 447,0c0.99997,-0.00001 0.99997,221.99998 0.99997,221.99998")';
        var InsideClipPath 			= 'clip-path: path("m223.99998,245.99998l-224.99998,30.00002c-0.00001,0.99998 0.99999,221.99998 0.99999,221.99998c0,0 446.99999,3 446.99999,3c0,0 0,-225.99999 0,-225.99999")';


        // ************   SUB-FUNCTION OBJECTS  ************
        var tagsInInventoryStore 	= inventoryStore.getCount();
        var beamsInInventoryStore 	= inventoryStore.collect('AntennaName').length;
        var currentEPC				= 'unknown';
        var inventoryEPC 			= 'unknown';
        var iterationEPC			= 'unknown';
        var antennaBeam				= 'unknown';
        var direction				= 'unknown';
        var rssi					= 0;
        var rssiTopBeam				= 0;
        var rssiBottomBeam			= 0;
        var bfaOrientation 			= Ext.data.StoreManager.lookup('BfaConfigStore').getAt(0).get('Orientation');




        // ************  DIRECTION TRACKING OBJECTS ************

        const Direction = {
            In:			'In',
            Out:		'Out'
        };

        const Items = {
            iphone: 		"iPhone 12",
            libertyCoin:	"1972 Liberty Coin US$1",
            vinylRecord:	"Vinyl Record Gold Coin US$5",
            swatch:			"Swatch Chrono Irony Edition",
            seiko:			"Seiko Prospex Automatic Divers"
        };

        const Beam = {
            TopBeam:		bfaConfigData.get('TopBeam'),
            BottomBeam:		bfaConfigData.get('BottomBeam')
        };



        // ╠═╠═════ SUB-FUNCTION:  Hide all Direction Arrows  ════=═════════════════════════════╣

        function hideAllDirectionArrows() {
            outArrow.hide();
            inArrow.hide();
        }



        // ╠═╠═════ SUB-FUNCTION:  Assign Item to the EPC  ═══════════════════════════╣

        function getItem(epc) {
            if (epc === "8000000006C526F301DBF1D8") {
                return Items.iphone;
            }
            else if (epc === "8000000006DA37FE001ECFAB") {
                return Items.libertyCoin;
            }
            else if (epc === "8000000006C525EF01DBF1D8") {
                return Items.vinylRecord;
            }
            else if (epc === "8000000006C525C801DBF1D8") {
                return Items.swatch;
            }
            else if (epc === "8000000006C50E91785A6ADE") {
                return Items.seiko;
            }
        }



        // ╠═╠═════ SUB-FUNCTION:  Reset the records in Inventory Store when a tag has maxTagCount or more records  ═══════════════════════════╣

        function cleanUpInventoryStore() {

            var marker 					= 0;
            var maxTagCount 			= 2;
            var duplicateTags		 	= [];

            if (tagsInInventoryStore > 1) {


                // Use the first EPC in the Inventory Store to set the value of iterationEPC
                iterationEPC = inventoryStore.getAt(0).get('EPC');

                for (var j = 0; j < tagsInInventoryStore; j++) {
                    inventoryEPC 	= inventoryStore.getAt(j).get('EPC');

                    if(inventoryEPC !== iterationEPC) {
                        if(j - marker >= maxTagCount) {
                            for(i = marker; i < j; i++) {
                                duplicateTags.push(inventoryStore.getAt(i));
                            }
                        }
                        marker = j;
                        iterationEPC = inventoryEPC;		//remember current EPC
                    }

                    else if (j === tagsInInventoryStore - 1 && tagsInInventoryStore - marker >= maxTagCount) {
                        for(i = marker; i < tagsInInventoryStore; i++) {
                            duplicateTags.push(inventoryStore.getAt(i));
                        }
                    }


                }

                //console.log("Duplicate Tags = " + duplicateTags.length);
                //console.dir(duplicateTags);


                // Cleanup Inventory Store
                if(duplicateTags.length > 1) {
                    //console.log("Cleaning the Inventory store");
                    Ext.Array.each(duplicateTags, function(record) {
                        inventoryStore.remove(record); // Remove each duplicate record
                    });
                    inventoryGrid.refresh();
                }

            }

        }




        // ╠═╠═════ SUB-FUNCTION:  Determine where the tags are (IN or OUT zone) applying threshold in the beams' overlap  ══════╣═╣

        function setTagDirection() {

            if (rssiTopBeam === 0 && rssiBottomBeam === 0) {
                console.log('**** Both beams are 0');
                return;
            }

            direction = 'unknown';
            var thresholdRssiOverlapOfBeams	= 1;     // default = 6
            var rssiIn 	= 0;
            var rssiOut	= 0;

            if (bfaOrientation === 'In') {
                rssiIn 	= rssiTopBeam;
                rssiOut	= rssiBottomBeam;
            }
            else if (bfaOrientation === 'Out') {
                rssiIn 	= rssiBottomBeam;
                rssiOut	= rssiTopBeam;
            }

            if (rssiIn - rssiOut > thresholdRssiOverlapOfBeams) {
                direction = Direction.In;
                //console.log ('In Beam is greater by ' + (rssiIn - rssiOut));
            }
            else if (rssiOut - rssiIn > thresholdRssiOverlapOfBeams) {
                direction = Direction.Out;
                //console.log ('Out Beam is greater by ' + (rssiOut - rssiIn));
            }
        }






        // ╠═╠═════ SUB-FUNCTION:  Update   ══════╣═╣

        function updateInOutStores() {

            if (direction !== 'unknown') {

                var isDirectionChanged			= false;
                var directionChangedThreshold 	= 0;

                //For the IN and OUT datagrids
                var directionModel		= Ext.create('RFID_Tag_Locator_Service.model.DirectionModel', {});
                var directionInStore 	= Ext.data.StoreManager.lookup('DirectionInStore');
                var directionOutStore 	= Ext.data.StoreManager.lookup('DirectionOutStore');
                var directionInOutStore	= Ext.data.StoreManager.lookup('DirectionInOutStore');
                var inStore 			= Ext.create('Ext.data.Store', { model: directionModel });
                var outStore 			= Ext.create('Ext.data.Store', { model: directionModel });

                //For the IN-OUT datagrid
                var directionInOutModel	= Ext.create('RFID_Tag_Locator_Service.model.DirectionInOutModel', {});
                var inOutStore			= Ext.create('Ext.data.Store', { model: directionInOutModel });

                //console.log('Dectected direction = ' + direction);

                directionModel.set("EPC", currentEPC);
                directionModel.set("item", getItem(currentEPC));
                directionInOutModel.set("EPC", currentEPC);
                directionInOutModel.set("item", getItem(currentEPC));
                directionInOutModel.set("direction", direction);
                directionInOutModel.set("directionChangedCounter", 0);

                var indexIn = directionInStore.findBy(function(rec) {
                    return rec.get('EPC') === currentEPC;
                });

                var indexOut = directionOutStore.findBy(function(rec) {
                    return rec.get('EPC') === currentEPC;
                });

                var indexInOut = directionInOutStore.findBy(function (rec) {
                    return rec.get('EPC') === currentEPC;
                });

                var targetRecord = directionInOutStore.getAt(indexInOut);



                // 1. Add new tag to the InOutStore
                // 2. If tag exists, verify if the direction is different from the current direction of the tag based on threshold for changeDirection
                // 3. If tag's directionChange threshold is met, then make changes to the store.
                // 4. Update GUI if tag is newly found or if there direction changed.


                // STEP 1:  Tag is newly found

                if(indexInOut === -1 ) {
                    directionInOutStore.add(directionInOutModel);
                    if(direction === Direction.In) {
                        directionInStore.add(directionModel);
                    }
                    else if (direction === Direction.Out) {
                        directionOutStore.add(directionModel);
                    }
                }





                // STEP2: Tag is already found, check direction change threshold if exceeded

                else {
                    var tagDirection			= targetRecord.get('direction');
                    var directionChangedCounter = targetRecord.get('directionChangedCounter');

                    if(direction !== tagDirection) {
                        if (directionChangedCounter >= directionChangedThreshold) {
                            isDirectionChanged = true;
                            targetRecord.set('directionChangedCounter', 0);
                            console.log('============== Change Counter exceeded.');
                        }
                        else {
                            targetRecord.set('directionChangedCounter', (directionChangedCounter + 1));
                            console.log('********* Change Counter Increased:  ' + directionChangedCounter + '  :   IN = ' + rssiBeam8 + ' ***   OUT = ' + rssiBeam14 );
                        }
                    }
                    else {
                        targetRecord.set('directionChangedCounter', 0);
                    }
                }




                // STEP 3:  Tag is already in the changed state (exceeded threshold)

                if (isDirectionChanged) {


                    targetRecord.set('direction', direction);

                    if(direction === Direction.In) {
                        directionInStore.add(directionModel);
                        directionOutStore.each(function(rec) {
                            if (rec.get('EPC') === currentEPC) {
                                directionOutStore.remove(rec);
                            }
                        });
                    }

                    else if (direction === Direction.Out) {
                        directionOutStore.add(directionModel);
                        directionInStore.each(function(rec) {
                            if (rec.get('EPC') === currentEPC) {
                                directionInStore.remove(rec);
                            }
                        });
                    }


                }




                // STEP 4:   Update GUI

                if(indexInOut === -1 || isDirectionChanged) {
                    if (direction === Direction.Out) {
                        hideAllDirectionArrows();
                        outArrow.show();
                        QuadrantBeam.setStyle(OutsideClipPath);
                        QuadrantBeam.show();
                    }
                    else if (direction === Direction.In) {
                        hideAllDirectionArrows();
                        inArrow.show();
                        QuadrantBeam.setStyle(InsideClipPath);
                        QuadrantBeam.show();
                    }

                    // Get total count of In and Out tags
                    var inCount = directionInStore.getCount();
                    var outCount = directionOutStore.getCount();
                    directionBarIn.setTitle('IN : ' + inCount);
                    directionBarOut.setTitle('OUT : ' + outCount);
                }

            }

        }





        // ╠═╠═╠═╠═════  MAIN-FUNCTION  ══════╣═╣═╣═╣


        // Get all Tags in the Inventory Store

        if (tagsInInventoryStore >= 1) {

            // Use the first EPC in the Inventory Store to set the value of the iterationEPC
            iterationEPC = inventoryStore.getAt(0).get('EPC');

            for (var j = 0; j < tagsInInventoryStore; j++) {
                inventoryEPC 	= inventoryStore.getAt(j).get('EPC');
                antennaBeam 	= inventoryStore.getAt(j).get('AntennaName');
                rssi 			= inventoryStore.getAt(j).get('ScaledRssi');

                // Determine In-Out zone if the current EPC is not the previous one

                if(inventoryEPC !== iterationEPC) {
                    currentEPC = iterationEPC;
                    //console.log("Setting direction of EPC # " + currentEPC);
                    setTagDirection();
                    updateInOutStores();
                    //Reset all beam states
                    rssiBottomBeam 		= 0;
                    rssiTopBeam		= 0;
                    iterationEPC 	= inventoryEPC;		//remember current EPC
                }

                if (antennaBeam == Beam.TopBeam) {
                    rssiTopBeam 	= rssi;
                }
                else if(antennaBeam == Beam.BottomBeam) {
                    rssiBottomBeam 	= rssi;
                }

            }

            // Handle the last EPC tag direction
            currentEPC = iterationEPC;
            //console.log("Setting direction of EPC # " + currentEPC);
            setTagDirection();
            updateInOutStores();
            //Reset all beam states
            rssiBottomBeam 	= 0;
            rssiTopBeam		= 0;

            // Cleanup Inventory Store that reached max beam count
            // cleanUpInventoryStore();
        }

    }

});